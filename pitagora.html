<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>アームワンダAIR ピタゴラメーカー V20 (Corrected Boost)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #222; font-family: sans-serif; touch-action: none;
            color: white;
        }
        #ui-layer {
            position: absolute; top: 0; right: 0;
            width: auto;
            pointer-events: none; z-index: 10; 
            text-align: right;
        }
        .header { 
            background: rgba(0,0,0,0.8); 
            padding: 15px; 
            border-bottom-left-radius: 15px;
            display: inline-block;
            min-width: 260px;
        }
        button {
            pointer-events: auto; padding: 8px 16px; font-size: 14px; font-weight: bold;
            border: none; border-radius: 6px; 
            background-color: #3498db; 
            color: white; cursor: pointer;
            box-shadow: 0 3px 0 #2980b9;
            transition: all 0.1s;
            margin-bottom: 10px;
            width: 100%;
        }
        button:active { transform: translateY(3px); box-shadow: none; }
        button.connected { background-color: #2ecc71; box-shadow: 0 3px 0 #27ae60; }
        
        .controls { pointer-events: auto; text-align: left; display: flex; flex-direction: column; gap: 8px; }
        .control-row { display: flex; align-items: center; justify-content: space-between; }
        .control-row label { font-size: 12px; width: 60px; }
        input[type=range] { width: 120px; accent-color: #3498db; cursor: pointer; }
        
        .hint { color: #bbb; font-size: 11px; margin-top: 10px; text-align: right; }
        .val-label { font-family: monospace; font-size: 14px; min-width: 45px; text-align: right;}
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="header">
            <button id="bleBtn" onclick="connectBle()">① BLE接続</button>
            
            <div class="controls">
                <div class="control-row">
                    <label for="boostRange">ブースト</label>
                    <input type="range" id="boostRange" min="0.02" max="0.3" step="0.01" value="0.1" oninput="updateLabels()">
                    <span id="boostVal" class="val-label">0.10倍</span>
                </div>
                <div class="control-row">
                    <label for="gravityRange">重力</label>
                    <input type="range" id="gravityRange" min="0.5" max="3.0" step="0.1" value="1.8" oninput="updateGravity()">
                    <span id="gravityVal" class="val-label">1.8</span>
                </div>
            </div>
            
            <div class="hint">タップで加速！</div>
        </div>
    </div>

    <audio id="goalSound" src="pitagora.mp3" preload="auto"></audio>

    <script>
        // --- 設定 ---
        const SERVICE_UUID = "a6b00001-0eda-4b52-8e2d-9b1c3d4e5f60";
        const DEVICE_NAME_PREFIX = "ArmOneDa-BLE-";
        
        // --- 変数 ---
        let bluetoothDevice, characteristic;
        let isGoalActive = false; 
        let currentBall = null; 
        let kaijuComposite = null; 
        let outOfBoundsTimer = 0;
        let currentBallType = null; 

        // --- Matter.js モジュール ---
        const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
              Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events,
              Body = Matter.Body, Vector = Matter.Vector;

        const engine = Engine.create();
        const world = engine.world;
        
        engine.gravity.y = 1.8;

        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#222',
                pixelRatio: 1 
            }
        });

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function updateLabels() {
            const val = parseFloat(document.getElementById('boostRange').value).toFixed(2);
            document.getElementById('boostVal').innerText = val + "倍";
        }
        
        function updateGravity() {
            const g = parseFloat(document.getElementById('gravityRange').value);
            engine.gravity.y = g;
            document.getElementById('gravityVal').innerText = g.toFixed(1);
        }

        // --- ステージ生成 ---
        function createStage() {
            Composite.clear(world);
            Engine.clear(engine);
            
            engine.gravity.y = parseFloat(document.getElementById('gravityRange').value);
            
            currentBall = null;
            outOfBoundsTimer = 0;

            const w = window.innerWidth;
            const h = window.innerHeight;
            render.canvas.width = w; render.canvas.height = h;

            // 1. 壁 + 天井
            const wallHeight = h * 5; 
            const wallThickness = 100;
            const wallOpt = { isStatic: true, restitution: 0.5, render: { fillStyle: '#444' } };
            
            Composite.add(world, [
                Bodies.rectangle(0, h/2, wallThickness, wallHeight, wallOpt),
                Bodies.rectangle(w, h/2, wallThickness, wallHeight, wallOpt),
                Bodies.rectangle(w/2, -wallThickness/2, w + wallThickness*2, wallThickness, wallOpt)
            ]);

            // 2. 床
            const floor = Bodies.rectangle(w/2, h - 10, w, 40, {
                isStatic: true, restitution: 1.2, label: 'Floor', render: { fillStyle: '#666' }
            });
            Composite.add(world, floor);

            // 3. スロープ
            const slopeCol = '#2ecc71'; 
            const slopeW = w * 0.75; 
            const slopeAngle = Math.PI * 0.05; 
            const createSlope = (x, y, angle) => {
                const slope = Bodies.rectangle(x, y, slopeW, 20, { 
                    isStatic: true, angle: angle, restitution: 1.2, friction: 0,
                    render: { fillStyle: slopeCol } 
                });
                Composite.add(world, slope);
            };
            createSlope(w * 0.3, h * 0.2, slopeAngle);
            createSlope(w * 0.7, h * 0.5, -slopeAngle);
            createSlope(w * 0.3, h * 0.8, slopeAngle);

            // 4. 怪獣
            const kx = w * 0.5;
            const ky = h * 0.5;
            const scale = 1.5;
            const partOpt = { render: { fillStyle: '#e74c3c' }, label: 'KaijuPart' };
            const eyeOpt = { render: { fillStyle: '#fff' }, label: 'KaijuPart' };
            const hornOpt = { angle: 0, render: { fillStyle: '#f1c40f' }, label: 'KaijuPart' };

            const kBody = Bodies.rectangle(kx, ky, 60 * scale, 50 * scale, partOpt);
            const kHead = Bodies.circle(kx, ky - 35 * scale, 25 * scale, partOpt);
            const kEyeL = Bodies.circle(kx - 10 * scale, ky - 35 * scale, 6 * scale, eyeOpt);
            const kEyeR = Bodies.circle(kx + 10 * scale, ky - 35 * scale, 6 * scale, eyeOpt);
            const kHornL = Bodies.polygon(kx - 20 * scale, ky - 55 * scale, 3, 10 * scale, { ...hornOpt, angle: -0.5 });
            const kHornR = Bodies.polygon(kx + 20 * scale, ky - 55 * scale, 3, 10 * scale, { ...hornOpt, angle: 0.5 });

            kaijuComposite = Body.create({
                parts: [kBody, kHead, kEyeL, kEyeR, kHornL, kHornR],
                isStatic: true,
                label: 'Kaiju'
            });
            Composite.add(world, kaijuComposite);

            // 5. ゴール (高さ200px)
            const goalSensor = Bodies.rectangle(w - 80, h - 130, 80, 200, {
                isStatic: true, isSensor: true, label: 'GoalSensor',
                render: { fillStyle: 'rgba(241, 196, 15, 0.4)' }
            });
            Composite.add(world, goalSensor);
        }

        createStage();
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // --- Update ---
        Events.on(engine, 'beforeUpdate', (event) => {
            const time = engine.timing.timestamp;

            if (kaijuComposite) {
                const startY = window.innerHeight * 0.5;
                const amplitude = 375; 
                const speed = 0.0004;
                const py = startY + Math.sin(time * speed) * amplitude;
                const safeY = Math.max(50, Math.min(window.innerHeight - 50, py));
                Body.setPosition(kaijuComposite, { x: window.innerWidth * 0.5, y: safeY });
                Body.setAngle(kaijuComposite, Math.sin(time * 0.001) * 0.1); 
            }

            if (currentBall && Composite.get(world, currentBall.id, 'body') && !currentBall.isFinished) {
                const pos = currentBall.position;
                const buffer = 50; 
                const isOut = pos.y > window.innerHeight + buffer || 
                              pos.x < -buffer || pos.x > window.innerWidth + buffer ||
                              pos.y < -buffer * 2;

                if (isOut) {
                    outOfBoundsTimer += 1000 / 60;
                    if (outOfBoundsTimer > 1000) { // 1秒リセット
                        Composite.remove(world, currentBall);
                        currentBall = null; 
                        outOfBoundsTimer = 0;
                    }
                } else {
                    outOfBoundsTimer = 0;
                }
            }
        });

        Events.on(render, 'afterRender', function() {
            const ctx = render.context;
            const w = render.canvas.width;
            const h = render.canvas.height;
            
            ctx.fillStyle = "white";
            ctx.font = "bold 24px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Finish", w - 80, h - 250);
            ctx.strokeStyle = "yellow";
            ctx.lineWidth = 2;
            ctx.strokeRect(w - 120, h - 230, 80, 200);
        });


        // --- Input ---
        function handleInput(x, y) {
            if (currentBall && Composite.get(world, currentBall.id, 'body')) {
                if (currentBall.isFinished) return;

                const velocity = currentBall.velocity;
                let direction = Vector.create(0, 0);
                if (Vector.magnitude(velocity) < 0.5) direction = Vector.create(1, 0.5);
                else direction = Vector.normalise(velocity);

                const boostVal = parseFloat(document.getElementById('boostRange').value);
                
                // ★修正: 0.25倍の補正係数を復活！
                const forceMagnitude = currentBall.mass * (boostVal * 0.25); 
                
                const force = Vector.mult(direction, forceMagnitude);

                Body.applyForce(currentBall, currentBall.position, force);
                playBoostSound();

            } else {
                spawnBall(x, y);
            }
        }

        function spawnBall(x, y) {
            if (currentBall) Composite.remove(world, currentBall);
            outOfBoundsTimer = 0;

            const radius = 30; 
            const types = [
                { color: '#e74c3c', rest: 1.0, name: 'Red' },
                { color: '#e67e22', rest: 1.1, name: 'Orange' },
                { color: '#f1c40f', rest: 0.8, name: 'Yellow' },
                { color: '#2ecc71', rest: 1.0, name: 'Green' },
                { color: '#3498db', rest: 0.9, name: 'Blue' },
                { color: '#9b59b6', rest: 1.2, name: 'Purple' },
                { color: '#ecf0f1', rest: 1.05, name: 'White' }
            ];
            const type = types[Math.floor(Math.random() * types.length)];
            currentBallType = type;

            currentBall = Bodies.circle(x, 50, radius, {
                restitution: type.rest, 
                density: 0.002, 
                frictionAir: 0.005, 
                label: 'Ball',
                render: { fillStyle: type.color, strokeStyle: '#fff', lineWidth: 3 }
            });
            currentBall.isFinished = false;

            Composite.add(world, currentBall);
            playPopSound();
        }

        document.body.addEventListener('mousedown', (e) => {
            if(e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
            handleInput(e.clientX, e.clientY);
        });
        document.body.addEventListener('touchstart', (e) => {
            if(e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
            if (e.touches.length > 0) {
                e.preventDefault();
                handleInput(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        // --- Collision ---
        Events.on(engine, 'collisionStart', (event) => {
            const pairs = event.pairs;
            for (let i = 0; i < pairs.length; i++) {
                const bodyA = pairs[i].bodyA;
                const bodyB = pairs[i].bodyB;
                const getLabel = (body) => body.label || (body.parent && body.parent.label);
                const check = (l1, l2) => {
                    const la = getLabel(bodyA), lb = getLabel(bodyB);
                    return (la === l1 && lb === l2) || (lb === l1 && la === l2);
                };
                if (check('Ball', 'Kaiju') || check('Ball', 'KaijuPart')) triggerExplosion();
                if (check('Ball', 'GoalSensor')) {
                    if(currentBall && !currentBall.isFinished) triggerGoal();
                }
            }
        });

        // --- Explosion (Healing Sound) ---
        function triggerExplosion() {
            if (!currentBall || currentBall.isFinished) return;
            playHealSound(); 
            createParticles(currentBall.position.x, currentBall.position.y, '#ffffff', 6);
            createParticles(currentBall.position.x, currentBall.position.y, '#00ffff', 6);
            Composite.remove(world, currentBall);
            currentBall = null;
        }

        function createParticles(x, y, color, count) {
            const particles = [];
            for(let i=0; i<count; i++){
                const p = Bodies.rectangle(x, y, 15, 15, { render: { fillStyle: color }, frictionAir: 0.05 });
                Body.setVelocity(p, { x: (Math.random()-0.5)*30, y: (Math.random()-0.5)*30 });
                particles.push(p);
            }
            Composite.add(world, particles);
            setTimeout(() => Composite.remove(world, particles), 1000);
        }

        function triggerGoal() {
            if (isGoalActive || !currentBall) return;
            isGoalActive = true;
            currentBall.isFinished = true; 
            sendCommand("#AMOS1ON!");
            const audio = document.getElementById("goalSound");
            if (audio) {
                audio.currentTime = 0;
                audio.onended = () => { finishSequence(); audio.onended = null; };
                audio.play().catch(e => { setTimeout(finishSequence, 1000); });
            } else { setTimeout(finishSequence, 1000); }
            createParticles(currentBall.position.x, currentBall.position.y, '#f1c40f', 20);
            createParticles(currentBall.position.x, currentBall.position.y, '#ffffff', 10);
        }

        function finishSequence() {
            sendCommand("#AMOS1OFF!");
            if (currentBall) { Composite.remove(world, currentBall); currentBall = null; }
            isGoalActive = false;
        }

        // --- Sound ---
        function playPopSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }
        function playBoostSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(300, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(500, audioCtx.currentTime + 0.1); 
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }
        function playHealSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const t = audioCtx.currentTime;
            [880, 1108, 1318].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine'; 
                osc.frequency.setValueAtTime(freq, t + i * 0.08);
                gain.gain.setValueAtTime(0.1, t + i * 0.08);
                gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.08 + 0.6);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(t + i * 0.08);
                osc.stop(t + i * 0.08 + 0.6);
            });
        }

        async function connectBle() {
            try {
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: DEVICE_NAME_PREFIX }],
                    optionalServices: [SERVICE_UUID]
                });
                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                const characteristics = await service.getCharacteristics();
                characteristic = characteristics.find(c => c.properties.write || c.properties.writeWithoutResponse);
                document.getElementById("bleBtn").innerText = "接続済み";
                document.getElementById("bleBtn").classList.add("connected");
                if (audioCtx.state === 'suspended') audioCtx.resume();
            } catch (error) { alert("接続失敗: " + error); }
        }
        async function sendCommand(cmd) {
            if (!characteristic) return;
            try { await characteristic.writeValue(new TextEncoder().encode(cmd)); } catch (e) {}
        }

        window.addEventListener('resize', createStage);
    </script>
</body>
</html>
